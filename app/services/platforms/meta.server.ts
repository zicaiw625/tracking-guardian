// Meta (Facebook) Conversions API integration

import type { ConversionData, MetaCredentials } from "../../types";
import { hashValue, normalizePhone } from "../../utils/crypto";

export async function sendConversionToMeta(
  credentials: MetaCredentials | null,
  conversionData: ConversionData
): Promise<any> {
  if (!credentials?.pixelId || !credentials?.accessToken) {
    throw new Error("Meta Pixel credentials not configured");
  }

  const eventTime = Math.floor(Date.now() / 1000);

  // Build user data with hashed PII
  const userData: any = {};
  
  if (conversionData.email) {
    userData.em = [await hashValue(conversionData.email.toLowerCase().trim())];
  }
  if (conversionData.phone) {
    userData.ph = [await hashValue(normalizePhone(conversionData.phone))];
  }
  if (conversionData.firstName) {
    userData.fn = [await hashValue(conversionData.firstName.toLowerCase())];
  }
  if (conversionData.lastName) {
    userData.ln = [await hashValue(conversionData.lastName.toLowerCase())];
  }
  if (conversionData.city) {
    userData.ct = [await hashValue(conversionData.city.toLowerCase().replace(/\s/g, ''))];
  }
  if (conversionData.state) {
    userData.st = [await hashValue(conversionData.state.toLowerCase())];
  }
  if (conversionData.country) {
    userData.country = [await hashValue(conversionData.country.toLowerCase())];
  }
  if (conversionData.zip) {
    userData.zp = [await hashValue(conversionData.zip.replace(/\s/g, ''))];
  }

  // Build contents array for product data
  const contents = conversionData.lineItems?.map((item) => ({
    id: item.productId,
    quantity: item.quantity,
    item_price: item.price,
  })) || [];

  const eventPayload = {
    data: [
      {
        event_name: "Purchase",
        event_time: eventTime,
        action_source: "website",
        user_data: userData,
        custom_data: {
          currency: conversionData.currency,
          value: conversionData.value,
          order_id: conversionData.orderId,
          contents,
          content_type: "product",
        },
      },
    ],
    ...(credentials.testEventCode && { test_event_code: credentials.testEventCode }),
  };

  // Make the API call to Meta Conversions API
  const response = await fetch(
    `https://graph.facebook.com/v18.0/${credentials.pixelId}/events?access_token=${credentials.accessToken}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(eventPayload),
    }
  );

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(`Meta API error: ${JSON.stringify(errorData)}`);
  }

  return await response.json();
}

// Generate Web Pixel code for Meta
export function generateMetaPixelCode(config: { pixelId: string }): string {
  return `// Meta (Facebook) Pixel - Web Pixel Implementation
// Auto-generated by Tracking Guardian

import {register, analytics} from '@shopify/web-pixels-extension';

register(({analytics, browser, settings}) => {
  const PIXEL_ID = '${config.pixelId}';

  // Initialize Meta Pixel
  !function(f,b,e,v,n,t,s)
  {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
  n.callMethod.apply(n,arguments):n.queue.push(arguments)};
  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
  n.queue=[];t=b.createElement(e);t.async=!0;
  t.src=v;s=b.getElementsByTagName(e)[0];
  s.parentNode.insertBefore(t,s)}(window, document,'script',
  'https://connect.facebook.net/en_US/fbevents.js');
  
  fbq('init', PIXEL_ID);
  fbq('track', 'PageView');

  // Track page views
  analytics.subscribe('page_viewed', (event) => {
    fbq('track', 'PageView');
  });

  // Track product views
  analytics.subscribe('product_viewed', (event) => {
    const product = event.data.productVariant;
    fbq('track', 'ViewContent', {
      content_ids: [product.id],
      content_name: product.title,
      content_type: 'product',
      value: parseFloat(product.price.amount),
      currency: product.price.currencyCode,
    });
  });

  // Track add to cart
  analytics.subscribe('product_added_to_cart', (event) => {
    const item = event.data.cartLine;
    fbq('track', 'AddToCart', {
      content_ids: [item.merchandise.id],
      content_name: item.merchandise.title,
      content_type: 'product',
      value: parseFloat(item.merchandise.price.amount) * item.quantity,
      currency: item.merchandise.price.currencyCode,
    });
  });

  // Track checkout initiated
  analytics.subscribe('checkout_started', (event) => {
    const checkout = event.data.checkout;
    fbq('track', 'InitiateCheckout', {
      content_ids: checkout.lineItems.map((item) => item.id),
      contents: checkout.lineItems.map((item) => ({
        id: item.id,
        quantity: item.quantity,
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
      num_items: checkout.lineItems.reduce((sum, item) => sum + item.quantity, 0),
    });
  });

  // Track payment info added
  analytics.subscribe('payment_info_submitted', (event) => {
    const checkout = event.data.checkout;
    fbq('track', 'AddPaymentInfo', {
      content_ids: checkout.lineItems.map((item) => item.id),
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
    });
  });

  // Track purchase
  analytics.subscribe('checkout_completed', (event) => {
    const checkout = event.data.checkout;
    fbq('track', 'Purchase', {
      content_ids: checkout.lineItems.map((item) => item.id),
      contents: checkout.lineItems.map((item) => ({
        id: item.id,
        quantity: item.quantity,
        item_price: parseFloat(item.variant?.price?.amount || '0'),
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
      order_id: checkout.order?.id || checkout.token,
      num_items: checkout.lineItems.reduce((sum, item) => sum + item.quantity, 0),
    });
  });
});
`;
}

// Helper functions imported from utils/crypto

