// TikTok Events API integration

import type { ConversionData, TikTokCredentials, ConversionApiResponse } from "../../types";
import { hashValue, normalizePhone, normalizeEmail } from "../../utils/crypto";

// Timeout configuration
const TIKTOK_API_TIMEOUT_MS = 30000; // 30 seconds

// TikTok user data interface
interface TikTokUserData {
  email?: string;  // SHA-256 hashed
  phone_number?: string;  // SHA-256 hashed
}

/**
 * Builds hashed user data for TikTok Events API
 */
async function buildHashedUserData(conversionData: ConversionData): Promise<TikTokUserData> {
  const user: TikTokUserData = {};
  
  if (conversionData.email) {
    user.email = await hashValue(normalizeEmail(conversionData.email));
  }
  if (conversionData.phone) {
    user.phone_number = await hashValue(normalizePhone(conversionData.phone));
  }
  
  return user;
}

/**
 * Sends conversion data to TikTok Events API
 * 
 * Deduplication:
 * - Uses event_id for client/server deduplication
 * - TikTok will ignore duplicate events with same event_id
 */
export async function sendConversionToTikTok(
  credentials: TikTokCredentials | null,
  conversionData: ConversionData,
  eventId?: string
): Promise<ConversionApiResponse> {
  if (!credentials?.pixelId || !credentials?.accessToken) {
    throw new Error("TikTok Pixel credentials not configured");
  }

  // Validate pixel ID format
  if (!/^[A-Z0-9]{20,}$/i.test(credentials.pixelId)) {
    throw new Error("Invalid TikTok Pixel ID format");
  }

  const timestamp = new Date().toISOString();

  // Build user data with hashed PII
  const user = await buildHashedUserData(conversionData);

  // Build contents array (no PII)
  const contents = conversionData.lineItems?.map((item) => ({
    content_id: item.productId,
    content_name: item.name,
    quantity: item.quantity,
    price: item.price,
  })) || [];

  // Generate event_id for deduplication if not provided
  const dedupeEventId = eventId || `${conversionData.orderId}_purchase_${Date.now()}`;

  const eventPayload = {
    pixel_code: credentials.pixelId,
    event: "CompletePayment",
    event_id: dedupeEventId, // For client/server deduplication
    timestamp,
    context: {
      user,
    },
    properties: {
      currency: conversionData.currency,
      value: conversionData.value,
      order_id: conversionData.orderId,
      contents,
      content_type: "product",
    },
    ...(credentials.testEventCode && { test_event_code: credentials.testEventCode }),
  };

  // Create abort controller for timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), TIKTOK_API_TIMEOUT_MS);

  try {
  // Make the API call to TikTok Events API
  const response = await fetch(
    "https://business-api.tiktok.com/open_api/v1.3/pixel/track/",
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Access-Token": credentials.accessToken,
      },
      body: JSON.stringify({ data: [eventPayload] }),
        signal: controller.signal,
    }
  );

  if (!response.ok) {
    const errorData = await response.json();
      // Don't expose full error details
      const errorMessage = errorData.message || "Unknown TikTok API error";
      throw new Error(`TikTok API error: ${errorMessage}`);
    }

    const result = await response.json();
    
    console.log(`TikTok conversion sent: order=${conversionData.orderId}`);

    return {
      success: true,
      conversionId: conversionData.orderId,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error(`TikTok API request timeout after ${TIKTOK_API_TIMEOUT_MS}ms`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

// Generate Web Pixel code for TikTok
// Uses browser.window/browser.document for Web Pixel sandbox compatibility
export function generateTikTokPixelCode(config: { pixelId: string }): string {
  return `// TikTok Pixel - Web Pixel Implementation
// Auto-generated by Tracking Guardian
// Compatible with Shopify Web Pixel strict sandbox

import { register } from '@shopify/web-pixels-extension';

register(({ analytics, browser }) => {
  const PIXEL_ID = '${config.pixelId}';
  
  // Idempotency guard - prevent double initialization
  if (browser.window.__TG_TIKTOK_LOADED) return;
  browser.window.__TG_TIKTOK_LOADED = true;

  // Event queue for events fired before SDK loads
  const eventQueue = [];
  let ttqReady = false;

  // Safe ttq wrapper that queues events until ready
  function safeTtq(method, ...args) {
    if (ttqReady && browser.window.ttq && browser.window.ttq[method]) {
      browser.window.ttq[method](...args);
    } else {
      eventQueue.push({ method, args });
    }
  }

  // Initialize TikTok Pixel using browser APIs (sandbox-compatible)
  !function (w, d, t) {
    w.TiktokAnalyticsObject=t;var ttq=w[t]=w[t]||[];ttq.methods=["page","track","identify","instances","debug","on","off","once","ready","alias","group","enableCookie","disableCookie"],ttq.setAndDefer=function(t,e){t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}};for(var i=0;i<ttq.methods.length;i++)ttq.setAndDefer(ttq,ttq.methods[i]);ttq.instance=function(t){for(var e=ttq._i[t]||[],n=0;n<ttq.methods.length;n++)ttq.setAndDefer(e,ttq.methods[n]);return e},ttq.load=function(e,n){var i="https://analytics.tiktok.com/i18n/pixel/events.js";ttq._i=ttq._i||{},ttq._i[e]=[],ttq._i[e]._u=i,ttq._t=ttq._t||{},ttq._t[e]=+new Date,ttq._o=ttq._o||{},ttq._o[e]=n||{};var o=d.createElement("script");o.type="text/javascript",o.async=!0,o.src=i+"?sdkid="+e+"&lib="+t;
      o.onload=function(){
        ttqReady = true;
        // Flush queued events
        eventQueue.forEach(({ method, args }) => {
          if (w.ttq && w.ttq[method]) w.ttq[method](...args);
        });
        eventQueue.length = 0;
      };
      var a=d.getElementsByTagName("script")[0];a.parentNode.insertBefore(o,a)};
    ttq.load(PIXEL_ID);
    ttq.page();
  }(browser.window, browser.document, 'ttq');

  // Track page views
  analytics.subscribe('page_viewed', (event) => {
    safeTtq('page');
  });

  // Track product views
  analytics.subscribe('product_viewed', (event) => {
    const product = event.data?.productVariant;
    if (!product) return;
    
    safeTtq('track', 'ViewContent', {
      content_id: product.id,
      content_name: product.title,
      content_type: 'product',
      value: parseFloat(product.price?.amount || '0'),
      currency: product.price?.currencyCode || 'USD',
    });
  });

  // Track add to cart
  analytics.subscribe('product_added_to_cart', (event) => {
    const item = event.data?.cartLine;
    if (!item?.merchandise) return;
    
    safeTtq('track', 'AddToCart', {
      content_id: item.merchandise.id,
      content_name: item.merchandise.title,
      content_type: 'product',
      value: parseFloat(item.merchandise.price?.amount || '0') * (item.quantity || 1),
      currency: item.merchandise.price?.currencyCode || 'USD',
      quantity: item.quantity || 1,
    });
  });

  // Track checkout initiated
  analytics.subscribe('checkout_started', (event) => {
    const checkout = event.data?.checkout;
    if (!checkout) return;
    
    const lineItems = checkout.lineItems || [];
    safeTtq('track', 'InitiateCheckout', {
      contents: lineItems.map((item) => ({
        content_id: item.id,
        content_name: item.title,
        quantity: item.quantity || 1,
        price: parseFloat(item.variant?.price?.amount || '0'),
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice?.amount || '0'),
      currency: checkout.currencyCode || 'USD',
    });
  });

  // Track purchase
  analytics.subscribe('checkout_completed', (event) => {
    const checkout = event.data?.checkout;
    if (!checkout) return;
    
    const lineItems = checkout.lineItems || [];
    safeTtq('track', 'CompletePayment', {
      contents: lineItems.map((item) => ({
        content_id: item.id,
        content_name: item.title,
        quantity: item.quantity || 1,
        price: parseFloat(item.variant?.price?.amount || '0'),
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice?.amount || '0'),
      currency: checkout.currencyCode || 'USD',
      order_id: checkout.order?.id || checkout.token,
    });
  });
});
`;
}

// Helper functions imported from utils/crypto

