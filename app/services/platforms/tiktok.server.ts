// TikTok Events API integration

import type { ConversionData, TikTokCredentials, ConversionApiResponse } from "../../types";
import { hashValue, normalizePhone, normalizeEmail } from "../../utils/crypto";

// Timeout configuration
const TIKTOK_API_TIMEOUT_MS = 30000; // 30 seconds

// TikTok user data interface
interface TikTokUserData {
  email?: string;  // SHA-256 hashed
  phone_number?: string;  // SHA-256 hashed
}

/**
 * Builds hashed user data for TikTok Events API
 */
async function buildHashedUserData(conversionData: ConversionData): Promise<TikTokUserData> {
  const user: TikTokUserData = {};
  
  if (conversionData.email) {
    user.email = await hashValue(normalizeEmail(conversionData.email));
  }
  if (conversionData.phone) {
    user.phone_number = await hashValue(normalizePhone(conversionData.phone));
  }
  
  return user;
}

/**
 * Sends conversion data to TikTok Events API
 */
export async function sendConversionToTikTok(
  credentials: TikTokCredentials | null,
  conversionData: ConversionData
): Promise<ConversionApiResponse> {
  if (!credentials?.pixelId || !credentials?.accessToken) {
    throw new Error("TikTok Pixel credentials not configured");
  }

  // Validate pixel ID format
  if (!/^[A-Z0-9]{20,}$/i.test(credentials.pixelId)) {
    throw new Error("Invalid TikTok Pixel ID format");
  }

  const timestamp = new Date().toISOString();

  // Build user data with hashed PII
  const user = await buildHashedUserData(conversionData);

  // Build contents array (no PII)
  const contents = conversionData.lineItems?.map((item) => ({
    content_id: item.productId,
    content_name: item.name,
    quantity: item.quantity,
    price: item.price,
  })) || [];

  const eventPayload = {
    pixel_code: credentials.pixelId,
    event: "CompletePayment",
    event_id: conversionData.orderId,
    timestamp,
    context: {
      user,
    },
    properties: {
      currency: conversionData.currency,
      value: conversionData.value,
      order_id: conversionData.orderId,
      contents,
      content_type: "product",
    },
    ...(credentials.testEventCode && { test_event_code: credentials.testEventCode }),
  };

  // Create abort controller for timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), TIKTOK_API_TIMEOUT_MS);

  try {
  // Make the API call to TikTok Events API
  const response = await fetch(
    "https://business-api.tiktok.com/open_api/v1.3/pixel/track/",
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Access-Token": credentials.accessToken,
      },
      body: JSON.stringify({ data: [eventPayload] }),
        signal: controller.signal,
    }
  );

  if (!response.ok) {
    const errorData = await response.json();
      // Don't expose full error details
      const errorMessage = errorData.message || "Unknown TikTok API error";
      throw new Error(`TikTok API error: ${errorMessage}`);
    }

    const result = await response.json();
    
    console.log(`TikTok conversion sent: order=${conversionData.orderId}`);

    return {
      success: true,
      conversionId: conversionData.orderId,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error(`TikTok API request timeout after ${TIKTOK_API_TIMEOUT_MS}ms`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

// Generate Web Pixel code for TikTok
export function generateTikTokPixelCode(config: { pixelId: string }): string {
  return `// TikTok Pixel - Web Pixel Implementation
// Auto-generated by Tracking Guardian

import {register, analytics} from '@shopify/web-pixels-extension';

register(({analytics, browser, settings}) => {
  const PIXEL_ID = '${config.pixelId}';

  // Initialize TikTok Pixel
  !function (w, d, t) {
    w.TiktokAnalyticsObject=t;var ttq=w[t]=w[t]||[];ttq.methods=["page","track","identify","instances","debug","on","off","once","ready","alias","group","enableCookie","disableCookie"],ttq.setAndDefer=function(t,e){t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}};for(var i=0;i<ttq.methods.length;i++)ttq.setAndDefer(ttq,ttq.methods[i]);ttq.instance=function(t){for(var e=ttq._i[t]||[],n=0;n<ttq.methods.length;n++)ttq.setAndDefer(e,ttq.methods[n]);return e},ttq.load=function(e,n){var i="https://analytics.tiktok.com/i18n/pixel/events.js";ttq._i=ttq._i||{},ttq._i[e]=[],ttq._i[e]._u=i,ttq._t=ttq._t||{},ttq._t[e]=+new Date,ttq._o=ttq._o||{},ttq._o[e]=n||{};var o=document.createElement("script");o.type="text/javascript",o.async=!0,o.src=i+"?sdkid="+e+"&lib="+t;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(o,a)};
    ttq.load(PIXEL_ID);
    ttq.page();
  }(window, document, 'ttq');

  // Track page views
  analytics.subscribe('page_viewed', (event) => {
    ttq.page();
  });

  // Track product views
  analytics.subscribe('product_viewed', (event) => {
    const product = event.data.productVariant;
    ttq.track('ViewContent', {
      content_id: product.id,
      content_name: product.title,
      content_type: 'product',
      value: parseFloat(product.price.amount),
      currency: product.price.currencyCode,
    });
  });

  // Track add to cart
  analytics.subscribe('product_added_to_cart', (event) => {
    const item = event.data.cartLine;
    ttq.track('AddToCart', {
      content_id: item.merchandise.id,
      content_name: item.merchandise.title,
      content_type: 'product',
      value: parseFloat(item.merchandise.price.amount) * item.quantity,
      currency: item.merchandise.price.currencyCode,
      quantity: item.quantity,
    });
  });

  // Track checkout initiated
  analytics.subscribe('checkout_started', (event) => {
    const checkout = event.data.checkout;
    ttq.track('InitiateCheckout', {
      contents: checkout.lineItems.map((item) => ({
        content_id: item.id,
        content_name: item.title,
        quantity: item.quantity,
        price: parseFloat(item.variant?.price?.amount || '0'),
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
    });
  });

  // Track purchase
  analytics.subscribe('checkout_completed', (event) => {
    const checkout = event.data.checkout;
    ttq.track('CompletePayment', {
      contents: checkout.lineItems.map((item) => ({
        content_id: item.id,
        content_name: item.title,
        quantity: item.quantity,
        price: parseFloat(item.variant?.price?.amount || '0'),
      })),
      content_type: 'product',
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
      order_id: checkout.order?.id || checkout.token,
    });
  });
});
`;
}

// Helper functions imported from utils/crypto

