// Google Ads Conversion API integration

interface ConversionData {
  orderId: string;
  orderNumber: string | null;
  value: number;
  currency: string;
  email?: string;
  phone?: string;
  firstName?: string;
  lastName?: string;
  city?: string;
  state?: string;
  country?: string;
  zip?: string;
  lineItems?: Array<{
    productId: string;
    variantId: string;
    name: string;
    quantity: number;
    price: number;
  }>;
}

interface GoogleCredentials {
  conversionId: string;
  conversionLabel: string;
  developerToken?: string;
  customerId?: string;
  clientId?: string;
  clientSecret?: string;
  refreshToken?: string;
}

export async function sendConversionToGoogle(
  credentials: GoogleCredentials | null,
  conversionData: ConversionData
): Promise<any> {
  if (!credentials?.conversionId || !credentials?.conversionLabel) {
    throw new Error("Google Ads credentials not configured");
  }

  // For server-side conversion tracking, we use Google Ads API
  // This is a simplified implementation - production would use the full Google Ads API
  
  const conversionPayload = {
    conversionAction: `customers/${credentials.customerId}/conversionActions/${credentials.conversionId}`,
    conversionDateTime: new Date().toISOString(),
    conversionValue: conversionData.value,
    currencyCode: conversionData.currency,
    orderId: conversionData.orderId,
    userIdentifiers: [] as any[],
  };

  // Add hashed user identifiers for enhanced conversions
  if (conversionData.email) {
    conversionPayload.userIdentifiers.push({
      hashedEmail: await hashValue(conversionData.email.toLowerCase().trim()),
    });
  }

  if (conversionData.phone) {
    conversionPayload.userIdentifiers.push({
      hashedPhoneNumber: await hashValue(normalizePhone(conversionData.phone)),
    });
  }

  // In production, you would make the actual API call here
  // For now, we'll simulate success
  console.log("Sending conversion to Google Ads:", conversionPayload);

  // Simulated response
  return {
    success: true,
    conversionId: conversionData.orderId,
    timestamp: new Date().toISOString(),
  };
}

// Generate Web Pixel code for Google Ads
export function generateGooglePixelCode(config: {
  measurementId: string;
  conversionId?: string;
  conversionLabel?: string;
}): string {
  return `// Google Analytics 4 & Google Ads - Web Pixel Implementation
// Auto-generated by Tracking Guardian

import {register, analytics} from '@shopify/web-pixels-extension';

register(({analytics, browser, settings}) => {
  const MEASUREMENT_ID = '${config.measurementId}';
  ${config.conversionId ? `const CONVERSION_ID = '${config.conversionId}';` : ''}
  ${config.conversionLabel ? `const CONVERSION_LABEL = '${config.conversionLabel}';` : ''}

  // Initialize gtag
  const script = document.createElement('script');
  script.src = \`https://www.googletagmanager.com/gtag/js?id=\${MEASUREMENT_ID}\`;
  script.async = true;
  document.head.appendChild(script);

  window.dataLayer = window.dataLayer || [];
  function gtag(...args) {
    window.dataLayer.push(args);
  }
  gtag('js', new Date());
  gtag('config', MEASUREMENT_ID);

  // Track page views
  analytics.subscribe('page_viewed', (event) => {
    gtag('event', 'page_view', {
      page_title: event.context.document.title,
      page_location: event.context.document.location.href,
    });
  });

  // Track product views
  analytics.subscribe('product_viewed', (event) => {
    const product = event.data.productVariant;
    gtag('event', 'view_item', {
      currency: product.price.currencyCode,
      value: parseFloat(product.price.amount),
      items: [{
        item_id: product.id,
        item_name: product.title,
        price: parseFloat(product.price.amount),
      }],
    });
  });

  // Track add to cart
  analytics.subscribe('product_added_to_cart', (event) => {
    const item = event.data.cartLine;
    gtag('event', 'add_to_cart', {
      currency: item.merchandise.price.currencyCode,
      value: parseFloat(item.merchandise.price.amount) * item.quantity,
      items: [{
        item_id: item.merchandise.id,
        item_name: item.merchandise.title,
        price: parseFloat(item.merchandise.price.amount),
        quantity: item.quantity,
      }],
    });
  });

  // Track checkout started
  analytics.subscribe('checkout_started', (event) => {
    const checkout = event.data.checkout;
    gtag('event', 'begin_checkout', {
      currency: checkout.currencyCode,
      value: parseFloat(checkout.totalPrice.amount),
      items: checkout.lineItems.map((item) => ({
        item_id: item.id,
        item_name: item.title,
        price: parseFloat(item.variant?.price?.amount || '0'),
        quantity: item.quantity,
      })),
    });
  });

  // Track purchase completion
  analytics.subscribe('checkout_completed', (event) => {
    const checkout = event.data.checkout;
    
    // GA4 purchase event
    gtag('event', 'purchase', {
      transaction_id: checkout.order?.id || checkout.token,
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
      tax: parseFloat(checkout.totalTax?.amount || '0'),
      shipping: parseFloat(checkout.shippingLine?.price?.amount || '0'),
      items: checkout.lineItems.map((item) => ({
        item_id: item.id,
        item_name: item.title,
        price: parseFloat(item.variant?.price?.amount || '0'),
        quantity: item.quantity,
      })),
    });
    ${
      config.conversionId && config.conversionLabel
        ? `
    // Google Ads conversion
    gtag('event', 'conversion', {
      send_to: \`\${CONVERSION_ID}/\${CONVERSION_LABEL}\`,
      value: parseFloat(checkout.totalPrice.amount),
      currency: checkout.currencyCode,
      transaction_id: checkout.order?.id || checkout.token,
    });`
        : ''
    }
  });
});
`;
}

// Helper functions
async function hashValue(value: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(value);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

function normalizePhone(phone: string): string {
  // Remove all non-numeric characters except leading +
  return phone.replace(/[^\d+]/g, "");
}

