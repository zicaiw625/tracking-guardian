// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Shopify Session storage for OAuth
model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)

  // Performance: Index for shop lookups (common in webhook/auth flows)
  @@index([shop])
}

// Shop information and subscription status
model Shop {
  id                String    @id @default(cuid())
  shopDomain        String    @unique
  accessToken       String?
  email             String?
  name              String?
  plan              String    @default("free") // free, starter, pro, enterprise
  monthlyOrderLimit Int       @default(100)
  installedAt       DateTime  @default(now())
  uninstalledAt     DateTime?
  isActive          Boolean   @default(true)

  // Privacy settings
  // When false, PII (email/phone/address) is NOT sent to ad platforms
  // This provides an extra layer of privacy compliance
  // Note: Server-side tracking always hashes PII before sending
  piiEnabled Boolean @default(false)

  // P1-3: Weak consent mode (DEPRECATED - use consentStrategy instead)
  // Kept for backwards compatibility
  weakConsentMode Boolean @default(false)

  // P0-5: Consent strategy for CAPI sending
  // - strict: Must have PixelEventReceipt with consent allowed
  // - balanced: Use receipt if available, otherwise use region/shop defaults
  // - weak: Allow sending without consent (for regions with implied consent)
  consentStrategy String @default("balanced")

  // Data retention settings (in days)
  // 0 means no auto-deletion (manual deletion required)
  dataRetentionDays Int @default(90)

  // P0-2: Ingestion secret for pixel event signature verification
  // Used to sign requests from the web pixel to prevent forgery/abuse
  // Generated on shop installation, can be regenerated in settings
  // SECURITY: This field is stored encrypted using AES-256-GCM
  // Made optional to support existing shops without secrets; afterAuth hook will populate
  ingestionSecret String?
  
  // P0-2: Previous ingestion secret for grace window during rotation
  // Allows old signatures to work for a brief period after rotation
  // Stored encrypted; cleared after grace window expires
  previousIngestionSecret String?
  previousSecretExpiry    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  scanReports           ScanReport[]
  pixelConfigs          PixelConfig[]
  alertConfigs          AlertConfig[]
  conversionLogs        ConversionLog[]
  reconciliationReports ReconciliationReport[]
  surveyResponses       SurveyResponse[]
  auditLogs             AuditLog[]
  monthlyUsages         MonthlyUsage[]
  pixelEventReceipts    PixelEventReceipt[]
  conversionJobs        ConversionJob[]
}

// Scan report for tracking scripts
model ScanReport {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  // Scan results
  additionalScripts Json? // Raw additional scripts content
  scriptTags        Json? // ScriptTag API results
  checkoutConfig    Json? // Checkout configuration

  // Risk analysis
  riskItems Json? // Array of identified risks
  riskScore Int   @default(0) // 0-100 risk score

  // Identified platforms
  identifiedPlatforms Json? // e.g., ["google", "meta", "tiktok"]

  status       String  @default("pending") // pending, scanning, completed, failed
  errorMessage String?

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([shopId])
  @@index([status])
}

// Pixel configuration for each platform
model PixelConfig {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  platform   String // google, meta, tiktok, bing, clarity
  platformId String? // e.g., GA4 Measurement ID, Meta Pixel ID

  // Platform-specific credentials (separated for security)
  // credentialsEncrypted: stores AES-256-GCM encrypted sensitive data (access tokens, API secrets)
  credentialsEncrypted String? // Encrypted string for server-side API credentials
  // clientConfig: stores non-sensitive configuration (conversion labels, event mappings)
  clientConfig         Json? // Non-sensitive client configuration

  // Legacy field - deprecated, use credentialsEncrypted instead
  // Kept for backwards compatibility during migration
  credentials Json? @map("credentials_legacy")

  // Configuration
  clientSideEnabled Boolean @default(true)
  serverSideEnabled Boolean @default(false)
  eventMappings     Json? // Custom event mappings

  // Migration status
  migrationStatus String    @default("not_started") // not_started, in_progress, completed
  migratedAt      DateTime?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([shopId, platform])
  @@index([shopId])
  @@index([platform])
}

// Alert configuration for monitoring
model AlertConfig {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  channel  String // email, slack, telegram
  settings Json // Channel-specific settings (email address, webhook URL, etc.)

  // Alert thresholds
  discrepancyThreshold Float @default(0.1) // 10% default threshold
  minOrdersForAlert    Int   @default(10) // Minimum orders before alerting

  // Alert frequency
  frequency String @default("daily") // daily, weekly, instant

  isEnabled   Boolean   @default(true)
  lastAlertAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([shopId])
  @@index([channel])
}

// Conversion tracking log
model ConversionLog {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  // Order info
  orderId     String // Real order ID (numeric or GID format)
  orderNumber String?
  orderValue  Decimal @db.Decimal(10, 2)
  currency    String  @default("USD")

  // Deduplication - deterministic event ID for platform CAPI dedup
  // Generated using generateEventId(orderId, eventType, shopDomain)
  // Used as event_id for Meta/TikTok and transaction_id for GA4
  eventId String?

  // Platform info
  platform  String // google, meta, tiktok
  eventType String // purchase, add_to_cart, etc.

  // Sending status
  // pending: initial state
  // sent: successfully sent to platform
  // failed: failed but may retry
  // retrying: currently in retry queue
  // dead_letter: permanently failed after max retries (manual intervention needed)
  status        String    @default("pending")
  attempts      Int       @default(0)
  maxAttempts   Int       @default(5) // Max retry attempts before dead letter
  lastAttemptAt DateTime?
  nextRetryAt   DateTime? // Scheduled next retry time (for exponential backoff)
  errorMessage  String?

  // Response from platform
  platformResponse Json?

  // Metadata
  clientSideSent Boolean @default(false)
  serverSideSent Boolean @default(false)

  // Dead letter handling
  deadLetteredAt  DateTime? // When moved to dead letter
  manuallyRetried Boolean   @default(false) // If manually retried from dead letter

  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@unique([shopId, orderId, platform, eventType])
  @@index([shopId])
  @@index([orderId])
  @@index([platform])
  @@index([status])
  @@index([createdAt])
  // Performance optimization: composite indexes for common queries
  @@index([shopId, createdAt])
  @@index([shopId, status])
  @@index([shopId, platform, createdAt])
  @@index([shopId, createdAt, status])
  // New indexes for retry processing
  @@index([status, nextRetryAt]) // For finding retryable logs
  @@index([status, deadLetteredAt]) // For dead letter management
}

// Daily reconciliation reports
model ReconciliationReport {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  platform   String // google, meta, tiktok
  reportDate DateTime @db.Date

  // Shopify data
  shopifyOrders  Int     @default(0)
  shopifyRevenue Decimal @default(0) @db.Decimal(12, 2)

  // Platform reported data
  platformConversions Int     @default(0)
  platformRevenue     Decimal @default(0) @db.Decimal(12, 2)

  // Calculated metrics
  orderDiscrepancy   Float @default(0) // Percentage difference
  revenueDiscrepancy Float @default(0)

  // Status
  status    String  @default("pending") // pending, completed, failed
  alertSent Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([shopId, platform, reportDate])
  @@index([shopId])
  @@index([platform])
  @@index([reportDate])
  // Performance: Composite index for date range queries by shop
  @@index([shopId, reportDate])
}

// Post-purchase survey responses
model SurveyResponse {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  orderId     String
  orderNumber String?

  // Survey data
  rating        Int? // 1-5 star rating
  feedback      String? // Open text feedback
  source        String? // How did you hear about us?
  customAnswers Json? // Custom survey question answers

  createdAt DateTime @default(now())

  @@index([shopId])
  @@index([orderId])
  // Performance: Composite index for checking existing response by shop+order
  @@index([shopId, orderId])
  // Analytics: Index for date-based analytics queries
  @@index([shopId, createdAt])
}

// Audit log for security-sensitive operations
model AuditLog {
  id     String @id @default(cuid())
  shopId String
  shop   Shop   @relation(fields: [shopId], references: [id], onDelete: Cascade)

  // Who performed the action
  actorType String // "user", "webhook", "cron", "api"
  actorId   String? // User email, webhook ID, etc.

  // What action was performed
  action       String // "token_updated", "pixel_config_changed", "threshold_changed", etc.
  resourceType String // "pixel_config", "alert_config", "shop", etc.
  resourceId   String? // ID of the affected resource

  // Action details
  previousValue Json? // Previous state (sensitive fields should be redacted)
  newValue      Json? // New state (sensitive fields should be redacted)
  metadata      Json? // Additional context

  // Request context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([shopId])
  @@index([action])
  @@index([resourceType])
  @@index([createdAt])
  // Query by shop and time range
  @@index([shopId, createdAt])
}

// P0-1: Monthly usage tracking for accurate billing
// Tracks successfully sent orders per month per shop
model MonthlyUsage {
  id        String   @id @default(cuid())
  shopId    String
  shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  yearMonth String   // Format: "2024-12"
  sentCount Int      @default(0) // Number of successfully sent orders this month

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([shopId, yearMonth])
  @@index([shopId])
  @@index([yearMonth])
}

// P0-3: Pixel event receipts - separate from ConversionLog
// Records pixel-side events for consent verification and diagnostics
model PixelEventReceipt {
  id        String   @id @default(cuid())
  shopId    String
  shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  orderId   String   // Normalized order ID
  eventType String   // checkout_completed, etc.
  eventId   String?  // Server-generated dedup ID

  // Pixel event metadata
  pixelTimestamp DateTime // When the pixel fired (client time)
  
  // P0-5: Consent state from pixel
  consentState   Json?    // {marketing: boolean, analytics: boolean}
  
  // Trust level
  isTrusted      Boolean  @default(false) // True if signature was valid
  signatureStatus String  @default("unsigned") // signed, unsigned, invalid
  
  // Diagnostics
  metadata       Json?    // Additional debug info

  createdAt DateTime @default(now())

  @@unique([shopId, orderId, eventType])
  @@index([shopId])
  @@index([orderId])
  @@index([shopId, orderId])
}

// P0-5: Webhook processing log for idempotency
// Stores fingerprints of processed webhooks to prevent duplicate processing
model WebhookLog {
  id        String   @id @default(cuid())
  
  // Webhook identification (composite key for deduplication)
  shopDomain   String    // Shop that sent the webhook
  webhookId    String    // Shopify's X-Shopify-Webhook-Id header
  topic        String    // Webhook topic (e.g., ORDERS_PAID)
  
  // Processing status
  status       String    @default("processed") // processed, failed
  
  // Order details (for reference)
  orderId      String?   // Order ID from payload (if applicable)
  
  // Timestamps
  receivedAt   DateTime  @default(now())
  processedAt  DateTime?
  
  // Prevent duplicate processing - unique on shop + webhookId + topic
  @@unique([shopDomain, webhookId, topic])
  
  // Performance indexes
  @@index([shopDomain])
  @@index([receivedAt])
  // Cleanup index - for periodic deletion of old entries
  @@index([receivedAt, status])
}

// P0-2: Conversion job queue for async webhook processing
// Webhook writes here, worker processes asynchronously
model ConversionJob {
  id        String   @id @default(cuid())
  shopId    String
  shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  // Order data (serialized webhook payload)
  orderId      String
  orderNumber  String?
  orderValue   Decimal  @db.Decimal(10, 2)
  currency     String   @default("USD")
  orderPayload Json     // Full webhook payload for retry

  // Job status
  // queued: waiting to be processed
  // processing: currently being processed
  // completed: successfully sent to all platforms
  // failed: failed but may retry
  // limit_exceeded: blocked due to billing limit
  // dead_letter: permanently failed
  status       String   @default("queued")
  
  // Processing metadata
  attempts     Int      @default(0)
  maxAttempts  Int      @default(5)
  lastAttemptAt DateTime?
  nextRetryAt  DateTime?
  errorMessage String?

  // Platform results (which platforms succeeded/failed)
  platformResults Json?  // {google: "sent", meta: "failed", tiktok: "pending"}

  // Timestamps
  createdAt    DateTime @default(now())
  processedAt  DateTime?
  completedAt  DateTime?

  @@unique([shopId, orderId])
  @@index([shopId])
  @@index([status])
  @@index([status, nextRetryAt])
  @@index([createdAt])
}
